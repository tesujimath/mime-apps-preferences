#!/usr/bin/env python

import os

import Tkinter

def strip_end(text, suffix):
    """Remove the suffix from the end of string, if possible."""
    if not text.endswith(suffix):
        return text
    return text[:len(text)-len(suffix)]

class App:
    """An application, with info from its desktop entry."""
    def __init__(self, desktop_dir, desktop_file):
        self._id = desktop_file
        attr = {}
        section = "<nosection>"
        with open(os.path.join(desktop_dir, desktop_file)) as f:
            for line in f:
                line = line.strip()
                if line.startswith("["):
                    #print("%s: skip header: %s" % (desktop_file, line))
                    section = line.lstrip("[").rstrip("]")
                elif line.startswith("#"):
                    #print("%s: skip comment: %s" % (desktop_file, line))
                    pass
                elif line == "":
                    #print("%s: skip empty: %s." % (desktop_file, line))
                    pass
                else:
                    tokens = line.split("=", 1)
                    if len(tokens) == 2:
                        if tokens[0] in ["Type", "Name", "MimeType"] and section == "Desktop Entry":
                            attr[tokens[0]] = tokens[1]
                    else:
                        print("%s: weird line: %s" % (desktop_file, line))
        if attr.has_key("Type"):
            self._type = attr["Type"]
        else:
            self._type = "<unknown>"
        if attr.has_key("Name"):
            self._name = attr["Name"]
        else:
            self._name = "<unknown>"
        self._mime_types = {}
        if attr.has_key("MimeType"):
            for mime_type in attr["MimeType"].rstrip(";").split(";"):
                self._mime_types[mime_type] = 1
        #print("%s: %s" % (self.id(), self.mime_types()))

    def remove_mime_types(self, mime_types):
        for mime_type in mime_types:
            if self._mime_types.has_key(mime_type):
                del self._mime_types[mime_type]

    def type(self):
        return self._type

    def id(self):
        return self._id

    def name(self):
        return self._name

    def qualified_name(self):
        """Append the id, for those apps with stupid names (hello gpicview)."""
        return "%s (%s)" % (self.name(), strip_end(self.id(), ".desktop"))

    def mime_types(self):
        return self._mime_types.keys()

    def supports_mime_type(self, mime_type):
        return self._mime_types.has_key(mime_type)

    def n_mime_types(self):
        return len(self._mime_types)

    def print_summary(self):
        print("%s: %d mime types" % (self.id(), self.n_mime_types()))

class Registry:
    def __init__(self):
        self._mime_types = {}   # list of app, by mime_type
        self._apps = {}         # app, by app_id
        self._blacklisted_mime_types = {} # (dict of mime_type) by app_id
        self._blacklisted_mime_types_list = None # cache

    def register(self, app):
        if self._apps.has_key(app.id()):
            print("warning: duplicate app %s" % app.id())
        else:
            self._apps[app.id()] = app
            for mime_type in app.mime_types():
                if not self._mime_types.has_key(mime_type):
                    self._mime_types[mime_type] = []
                self._mime_types[mime_type].append(app)

    def print_summary(self):
        print("Registry: %d applications, %d mime types" % (len(self._apps), len(self._mime_types)))
        for id in sorted(self._apps.keys()):
            self._apps[id].print_summary()

    def discard_unique_mime_types(self):
        """Discard any mime types for which there is only one application."""
        unique_mime_types = []
        for mime_type in self._mime_types.keys():
            if len(self._mime_types[mime_type]) == 1:
                unique_mime_types.append(mime_type)
                del self._mime_types[mime_type]
        #print("discarding %s" % ' '.join(unique_mime_types))
        # now remove these mime types from all apps
        for id in self._apps.keys():
            app = self._apps[id]
            app.remove_mime_types(unique_mime_types)
            # if any app doesn't have any interesting mime types, remove it
            if app.n_mime_types() == 0:
                #print("discarding %s" % id)
                del self._apps[id]
        # finally cache sorted apps and mime_types lists
        self._all_sorted_apps = sorted(self._apps.values(), key=lambda(app): app.qualified_name())
        self._all_sorted_mime_types = sorted(self._mime_types.keys())

    def all_apps(self):
        return self._all_sorted_apps

    def all_mime_types(self):
        return self._all_sorted_mime_types

    def app_by_id(self, app_id):
        if self._apps.has_key(app_id):
            app = self._apps[app_id]
            return app
        else:
            print("oops, can't find %s" % app_id)

    def related_apps(self, app):
        """Return apps related to given one, i.e. with overlapping mime types."""
        apps = {}               # app by app_id
        for mime_type in app.mime_types():
            for app in self._mime_types[mime_type]:
                apps[app.id()] = app
        return apps

    def apps_for_mime_type(self, mime_type):
        """Return list of apps which support given mime type."""
        return self._mime_types[mime_type]

    def blacklist_mime_type(self, app_id, mime_type):
        print("blacklist %s: %s" % (app_id, mime_type))
        self._blacklisted_mime_types_list = None
        if not self._blacklisted_mime_types.has_key(app_id):
            self._blacklisted_mime_types[app_id] = {}
        self._blacklisted_mime_types[app_id][mime_type] = 1

    def unblacklist_mime_type(self, app_id, mime_type):
        print("unblacklist %s: %s" % (app_id, mime_type))
        self._blacklisted_mime_types_list = None
        if self._blacklisted_mime_types.has_key(app_id) and self._blacklisted_mime_types[app_id].has_key(mime_type):
            del self._blacklisted_mime_types[app_id][mime_type]
            if len(self._blacklisted_mime_types[app_id]) == 0:
                del self._blacklisted_mime_types[app_id]

    def blacklisted_mime_types(self):
        if self._blacklisted_mime_types_list is not None:
            return self._blacklisted_mime_types_list
        self._blacklisted_mime_types_list = []
        for app_id in sorted(self._blacklisted_mime_types.keys(), key=lambda(id): self._apps[id].qualified_name()):
            for mime_type in sorted(self._blacklisted_mime_types[app_id].keys()):
                self._blacklisted_mime_types_list.append((app_id, mime_type))
        return self._blacklisted_mime_types_list

class ScrollingListbox(Tkinter.Frame):
    def __init__(self, master, height, width, showfn = None, selectfn = None):
        Tkinter.Frame.__init__(self, master)
        self.items = []
        self._selected_index = None
        self.showfn = showfn
        self.selectfn = selectfn
        self.scrollbar = Tkinter.Scrollbar(self, orient=Tkinter.VERTICAL)
        self.listbox = Tkinter.Listbox(self, selectmode=Tkinter.BROWSE, height=height, width=width, yscrollcommand=self.scrollbar.set, exportselection=0)
        self.listbox.bind("<<ListboxSelect>>", self._select)
        self.listbox.grid(row=0, column=0)
        self.scrollbar.config(command=self.listbox.yview)
        self.scrollbar.grid(row=0, column=1, sticky=Tkinter.N + Tkinter.S)

    def _select(self, e):
        """Select, or unselect."""
        index = int(e.widget.curselection()[0])
        if index == self._selected_index:
            self._selected_index = None
            self._selected_item = None
            self.listbox.selection_clear(index)
        else:
            self._selected_index = index
            self._selected_item = self.items[self._selected_index]
        if self.selectfn is not None:
            self.selectfn(self._selected_item, self._selected_index)

    def unselect(self):
        for i in [int(s) for s in self.listbox.curselection()]:
            self.listbox.selection_clear(i)
        self._selected_index = None

    def _item_as_string(self, item):
        """Return item as string for display."""
        if not self.showfn:
            return item
        else:
            return self.showfn(item)

    def selected_index(self):
        """return selection index if any, else None."""
        return self._selected_index

    def selected_item(self):
        """return selection item if any, else None."""
        if self._selected_index is None:
            return None
        else:
            return self.items[self._selected_index]

    def select_by_index(self, i):
        """Select the given index."""
        self.unselect()
        self._selected_index = i
        self.listbox.selection_set(i)

    def populate(self, items):
        #print("populate(%s), index is %s of %s" % (','.join([self._item_as_string(x) for x in items]), str(self._selected_index), ','.join([self._item_as_string(x) for x in self.items])))
        self.listbox.delete(0, Tkinter.END)
        if self._selected_index is not None:
            # preserve the selection if it occurs in the new list
            currently_selected_item = self.items[self._selected_index]
            self.unselect()
            if currently_selected_item in items:
                self._selected_index = items.index(currently_selected_item)
            else:
                self._selected_index = None
        self.items = items
        for item in self.items:
            self.listbox.insert(Tkinter.END, self._item_as_string(item))
        if self._selected_index is not None:
            self.select_by_index(self._selected_index)

class Shuttler(Tkinter.Frame):
    """Shuttles items between two ScrollingLists."""

    def __init__(self, master, scrolling_listboxes, shuttle_callback_fn):
        Tkinter.Frame.__init__(self, master)
        labels = ["<<", ">>"]
        self.scrolling_listboxes = scrolling_listboxes
        self.shuttle_callback_fn = shuttle_callback_fn
        self.shuttle_buttons = []
        for i in range(len(self.scrolling_listboxes)):
            self.shuttle_buttons.append(Tkinter.Button(self, text=labels[i], command=lambda index=(1 - i): self.shuttle(index)))
            self.shuttle_buttons[-1].grid(row=i, column=0)

    def shuttle(self, d):
        print("shuttle(%d)" % d)
        i = self.scrolling_listboxes[d].selected_index()
        if i is not None:
            print("shuttling %d" % i)
            self.shuttle_callback_fn(d, i)

class MyApp:
    def __init__(self, master):
        self.frame = Tkinter.Frame(master)

        self.selected_app = None
        self.selected_mime_type = None

        self.registry = Registry()

        self.global_preference = [] # list of app_id, in preference order
        self.related_apps = {}       # app by app_id
        self.preferred_apps = []     # list of app_id
        self.dontcare_apps = []      # list of app_id

        nextrow = 0

        self.apps_label = Tkinter.Label(self.frame, text = "Applications")
        self.apps_label.grid(row = nextrow, column = 0)
        self.supported_mime_types_label = Tkinter.Label(self.frame, text = "Mime Types")
        self.supported_mime_types_label.grid(row = nextrow, column = 1)
        self.blacklisted_mime_types_label = Tkinter.Label(self.frame, text = "Blacklisted Mime Types")
        self.blacklisted_mime_types_label.grid(row = nextrow, column = 3)
        nextrow += 1

        listbox_width = 40
        listbox_height = 20
        self.apps_scrolling_listbox = ScrollingListbox(self.frame, height=listbox_height, width=listbox_width, showfn=lambda x: x.qualified_name(), selectfn=self.select_from_apps)
        self.apps_scrolling_listbox.grid(row=nextrow, column=0)
        self.supported_mime_types_scrolling_listbox = ScrollingListbox(self.frame, height=listbox_height, width=listbox_width, selectfn=self.select_from_supported_mime_types)
        self.supported_mime_types_scrolling_listbox.grid(row=nextrow, column=1)
        self.blacklisted_mime_types_scrolling_listbox = ScrollingListbox(self.frame, height=listbox_height, width=listbox_width,
                                                                         showfn=lambda x: "%s: %s" % (self.registry.app_by_id(x[0]).qualified_name(), x[1]),
                                                                         selectfn=self.select_from_blacklisted_mime_types)
        self.blacklisted_mime_types_scrolling_listbox.grid(row=nextrow, column=3)

        self.mime_type_shuttler = Shuttler(self.frame, [self.supported_mime_types_scrolling_listbox, self.blacklisted_mime_types_scrolling_listbox], self.shuttle_mime_type)
        self.mime_type_shuttler.grid(row=nextrow, column=2)
        nextrow += 1

        self.global_preference_label = Tkinter.Label(self.frame, text = "Global Preferences")
        self.global_preference_label.grid(row = nextrow, column = 0)
        self.preferred_apps_label = Tkinter.Label(self.frame, text = "Preferred Applications for Mime Type(s)")
        self.preferred_apps_label.grid(row = nextrow, column = 1)
        self.dontcare_apps_label = Tkinter.Label(self.frame, text = "Dontcare Applications")
        self.dontcare_apps_label.grid(row = nextrow, column = 3)
        nextrow += 1

        self.global_preference_scrolling_listbox = ScrollingListbox(self.frame, height=listbox_height, width=listbox_width, selectfn=self.select_from_global_preference)
        self.global_preference_scrolling_listbox.grid(row=nextrow, column=0)

        self.preferred_apps_scrolling_listbox = ScrollingListbox(self.frame, height=listbox_height, width=listbox_width, selectfn=self.select_from_preferred_apps)
        self.preferred_apps_scrolling_listbox.grid(row=nextrow, column=1)

        self.dontcare_apps_scrolling_listbox = ScrollingListbox(self.frame, height=listbox_height, width=listbox_width, selectfn=self.select_from_dontcare_apps)
        self.dontcare_apps_scrolling_listbox.grid(row=nextrow, column=3)

        self.app_shuttler = Shuttler(self.frame, [self.preferred_apps_scrolling_listbox, self.dontcare_apps_scrolling_listbox], self.shuttle_app)
        self.app_shuttler.grid(row=nextrow, column=2)
        nextrow += 1

        self.preferred_buttonbox = Tkinter.Frame(self.frame)
        self.promote_preferred_button = Tkinter.Button(self.preferred_buttonbox, text="+", command=self.promote_preferred)
        self.promote_preferred_button.grid(row=0, column=0)
        self.demote_preferred_button = Tkinter.Button(self.preferred_buttonbox, text="-", command=self.demote_preferred)
        self.demote_preferred_button.grid(row=0, column=1)
        self.preferred_buttonbox.grid(row=nextrow, column=1)

        self.read_desktop_files()
        self.populate_apps_listbox()
        self.populate_supported_mime_types_listbox()

        self.frame.pack()

    def shuttle_app(self, d, i):
        print("shuttle_app(%d, %d)" % (d, i))
        if d == 0:
            this_app_id = self.preferred_apps[i]
            print("forget %d" % i)
            self.global_preference.remove(this_app_id)
            self.populate_preferred_dontcare_listboxes()
            self.dontcare_apps_scrolling_listbox.select_by_index(self.dontcare_apps.index(this_app_id))
            self.populate_global_preference_listbox()
        else:
            this_app_id = self.dontcare_apps[i]
            print("prefer %d" % i)
            self.global_preference.append(this_app_id)
            self.populate_preferred_dontcare_listboxes()
            self.preferred_apps_scrolling_listbox.select_by_index(self.preferred_apps.index(this_app_id))
            self.populate_global_preference_listbox()

    def shuttle_mime_type(self, d, i):
        print("shuttle_mime_type(%d, %d)" % (d, i))
        if d == 0:
            app = self.apps_scrolling_listbox.selected_item()
            mime_type = self.supported_mime_types_scrolling_listbox.selected_item()
            if app is not None and mime_type is not None:
                self.registry.blacklist_mime_type(app.id(), mime_type)
                self.populate_supported_mime_types_listbox()
                self.populate_blacklisted_mime_types_listbox()
        else:
            (app_id, mime_type) = self.registry.blacklisted_mime_types()[i]
            self.registry.unblacklist_mime_type(app_id, mime_type)
            self.populate_supported_mime_types_listbox()
            self.populate_blacklisted_mime_types_listbox()

    def promote_preferred(self):
        i = self.preferred_apps_scrolling_listbox.selected_index()
        if i is not None and i > 0:
            this_app_id = self.preferred_apps[i]
            prev_app_id = self.preferred_apps[i - 1]
            print("promote %d %s" % (i, this_app_id))
            self.global_preference.remove(this_app_id)
            new_position = self.global_preference.index(prev_app_id)
            self.global_preference.insert(new_position, this_app_id)
            self.populate_preferred_dontcare_listboxes()
            self.preferred_apps_scrolling_listbox.select_by_index(self.preferred_apps.index(this_app_id))
            self.populate_global_preference_listbox()

    def demote_preferred(self):
        i = self.preferred_apps_scrolling_listbox.selected_index()
        if i is not None and i < len(self.preferred_apps) - 1:
            this_app_id = self.preferred_apps[i]
            next_app_id = self.preferred_apps[i + 1]
            print("demote %d %s" % (i, this_app_id))
            self.global_preference.remove(this_app_id)
            new_position = self.global_preference.index(next_app_id) + 1
            self.global_preference.insert(new_position, this_app_id)
            self.populate_preferred_dontcare_listboxes()
            self.preferred_apps_scrolling_listbox.select_by_index(self.preferred_apps.index(this_app_id))
            self.populate_global_preference_listbox()

    def read_desktop_files(self):
        datadirs = os.getenv("XDG_DATA_DIRS")
        if not datadirs:
            datadirs = "/usr/local/share/:/usr/share/"
        applications_dirs = {}
        for datadir in datadirs.split(":"):
            applications_dir = os.path.join(datadir, "applications")
            if os.path.exists(applications_dir):
                applications_dirs[applications_dir] = 1
        #print("looking in %s" % " ".join(applications_dirs.keys()))
        for applications_dir in applications_dirs.keys():
            for filename in os.listdir(applications_dir):
                if filename.endswith(".desktop"):
                    app = App(applications_dir, filename)
                    if app.type() == "Application" and app.n_mime_types() > 0:
                        self.registry.register(app)
        self.registry.discard_unique_mime_types()

    def populate_apps_listbox(self):
        if self.selected_mime_type:
            app_list = self.registry.apps_for_mime_type(self.selected_mime_type)
        else:
            app_list = self.registry.all_apps()
        self.apps_scrolling_listbox.populate(app_list)

    def populate_supported_mime_types_listbox(self):
        if self.selected_app is not None:
            mime_type_list = sorted(self.selected_app.mime_types())
        else:
            mime_type_list = self.registry.all_mime_types()
        self.supported_mime_types_scrolling_listbox.populate(mime_type_list)

    def populate_blacklisted_mime_types_listbox(self):
        print("populating blacklist with %s" % self.registry.blacklisted_mime_types())
        self.blacklisted_mime_types_scrolling_listbox.populate(self.registry.blacklisted_mime_types())

    def populate_preferred_dontcare_listboxes(self):
        self.preferred_apps = []
        for app_id in self.global_preference:
            if app_id in self.related_apps.keys():
                self.preferred_apps.append(app_id)
        dontcare_apps = sorted([self.registry.app_by_id(app_id) for app_id in self.related_apps.keys() if app_id not in self.preferred_apps], key=lambda(app): app.qualified_name())
        self.dontcare_apps = [app.id() for app in dontcare_apps]
        self.preferred_apps_scrolling_listbox.populate([self.registry.app_by_id(app_id).qualified_name() for app_id in self.preferred_apps])
        self.dontcare_apps_scrolling_listbox.populate([self.registry.app_by_id(app_id).qualified_name() for app_id in self.dontcare_apps])

    def populate_global_preference_listbox(self):
        self.global_preference_scrolling_listbox.populate([self.registry.app_by_id(app_id).qualified_name() for app_id in self.global_preference])

    def select_from_apps(self, app, i):
        self.selected_app = app
        if app is not None:
            print("select_from_apps %d: %s" % (i, self.selected_app.qualified_name()))
            self.related_apps = self.registry.related_apps(self.selected_app)
        else:
            print("unselect_from_apps")
            self.related_apps = {}
        self.populate_preferred_dontcare_listboxes()
        self.populate_supported_mime_types_listbox()

    def select_from_supported_mime_types(self, mime_type, i):
        self.selected_mime_type = mime_type
        self.populate_apps_listbox()

    def select_from_blacklisted_mime_types(self, mime_type, i):
        print("select_from_blacklisted_mime_types %d: %s" % (i, mime_type))

    def select_from_global_preference(self, app_id, i):
        print("select_from_global_preference %d: %s" % (i, app_id))

    def select_from_preferred_apps(self, app_id, i):
        print("select_from_preferred_apps %d: %s" % (i, app_id))

    def select_from_dontcare_apps(self, app_id, i):
        print("select_from_dontcare_apps %d: %s" % (i, app_id))

def main():
    root = Tkinter.Tk()
    root.wm_title("mime-apps-preferences")
    app = MyApp(root)
    root.mainloop()

if __name__ == '__main__':
    main()
