#!/usr/bin/env python

import os

import Tkinter

def strip_end(text, suffix):
    """Remove the suffix from the end of string, if possible."""
    if not text.endswith(suffix):
        return text
    return text[:len(text)-len(suffix)]

class App:
    def __init__(self, desktop_dir, desktop_file):
        self._id = desktop_file
        attr = {}
        section = "<nosection>"
        with open(os.path.join(desktop_dir, desktop_file)) as f:
            for line in f:
                line = line.strip()
                if line.startswith("["):
                    #print("%s: skip header: %s" % (desktop_file, line))
                    section = line.lstrip("[").rstrip("]")
                elif line.startswith("#"):
                    #print("%s: skip comment: %s" % (desktop_file, line))
                    pass
                elif line == "":
                    #print("%s: skip empty: %s." % (desktop_file, line))
                    pass
                else:
                    tokens = line.split("=", 1)
                    if len(tokens) == 2:
                        if tokens[0] in ["Type", "Name", "MimeType"] and section == "Desktop Entry":
                            attr[tokens[0]] = tokens[1]
                    else:
                        print("%s: weird line: %s" % (desktop_file, line))
        if attr.has_key("Type"):
            self._type = attr["Type"]
        else:
            self._type = "<unknown>"
        if attr.has_key("Name"):
            self._name = attr["Name"]
        else:
            self._name = "<unknown>"
        self._mime_types = {}
        if attr.has_key("MimeType"):
            for mime_type in attr["MimeType"].rstrip(";").split(";"):
                self._mime_types[mime_type] = 1

    def remove_mime_types(self, mime_types):
        for mime_type in mime_types:
            if self._mime_types.has_key(mime_type):
                del self._mime_types[mime_type]

    def type(self):
        return self._type

    def id(self):
        return self._id

    def name(self):
        return self._name

    def qualified_name(self):
        """Append the id, for those apps with stupid names (hello gpicview)."""
        return "%s (%s)" % (self.name(), strip_end(self.id(), ".desktop"))

    def mime_types(self):
        return self._mime_types.keys()

    def n_mime_types(self):
        return len(self._mime_types)

    def print_summary(self):
        print("%s: %d mime types" % (self.id(), self.n_mime_types()))

class Registry:
    def __init__(self):
        self._mime_types = {}
        self._apps = {}

    def register(self, app):
        if self._apps.has_key(app.id()):
            print("warning: duplicate app %s" % app.id())
        else:
            self._apps[app.id()] = app
            for mime_type in app.mime_types():
                if not self._mime_types.has_key(mime_type):
                    self._mime_types[mime_type] = []
                self._mime_types[mime_type].append(app)

    def print_summary(self):
        print("Registry: %d applications, %d mime types" % (len(self._apps), len(self._mime_types)))
        for id in sorted(self._apps.keys()):
            self._apps[id].print_summary()

    def discard_unique_mime_types(self):
        """Discard any mime types for which there is only one application."""
        unique_mime_types = []
        for mime_type in self._mime_types.keys():
            if len(self._mime_types[mime_type]) == 1:
                unique_mime_types.append(mime_type)
                del self._mime_types[mime_type]
        # now remove these mime types from all apps
        for id in self._apps.keys():
            app = self._apps[id]
            app.remove_mime_types(unique_mime_types)
            # if any app doesn't have any interesting mime types, remove it
            if app.n_mime_types() <= 1:
                del self._apps[id]
        # finally generate a list of sorted apps
        self._sorted_apps = sorted(self._apps.values(), key=lambda(app): app.name())

    def apps(self):
        return self._sorted_apps

class ScrollingListbox(Tkinter.Frame):
    def __init__(self, master, height, width):
        Tkinter.Frame.__init__(self, master)
        self.scrollbar = Tkinter.Scrollbar(self, orient=Tkinter.VERTICAL)
        self.listbox = Tkinter.Listbox(self, selectmode=Tkinter.BROWSE, height=height, width=width, yscrollcommand=self.scrollbar.set)
        self.listbox.grid(row=0, column=0)
        self.scrollbar.config(command=self.listbox.yview)
        self.scrollbar.grid(row=0, column=1, sticky=Tkinter.N + Tkinter.S)

    def populate(self, items):
        self.listbox.delete(0, Tkinter.END)
        for item in items:
            self.listbox.insert(Tkinter.END, item)

class MyApp:
    def __init__(self, master):
        self.frame = Tkinter.Frame(master)
        nextrow = 0

        self.all_apps_scrolling_listbox = ScrollingListbox(self.frame, height=10, width=40)
        self.all_apps_scrolling_listbox.grid(row=nextrow, column=0)
        nextrow += 1

        self.registry = Registry()
        self.read_desktop_files()
        self.populate_all_apps_listbox()

        self.frame.pack()

    def read_desktop_files(self):
        datadirs = os.getenv("XDG_DATA_DIRS")
        if not datadirs:
            datadirs = "/usr/local/share/:/usr/share/"
        applications_dirs = {}
        for datadir in datadirs.split(":"):
            applications_dir = os.path.join(datadir, "applications")
            if os.path.exists(applications_dir):
                applications_dirs[applications_dir] = 1
        print("looking in %s" % " ".join(applications_dirs.keys()))
        for applications_dir in applications_dirs.keys():
            for filename in os.listdir(applications_dir):
                if filename.endswith(".desktop"):
                    app = App(applications_dir, filename)
                    if app.type() == "Application" and app.n_mime_types() > 0:
                        self.registry.register(app)
        self.registry.discard_unique_mime_types()
        self.registry.print_summary()

    def populate_all_apps_listbox(self):
        self.all_apps_scrolling_listbox.populate([app.qualified_name() for app in self.registry.apps()])

def main():
    root = Tkinter.Tk()
    root.wm_title("mime-apps-preferences")
    app = MyApp(root)
    root.mainloop()

if __name__ == '__main__':
    main()
